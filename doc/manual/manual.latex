%  Copyright 1990, 1991, 1992, Brown University, Providence, RI
%  
% This program is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 2 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%
\documentstyle[twocolumn,times]{article}
\input{psfig}
\input{squeeze.sty}
\begin{document}
\title{The Fnord Manual}
\author{Scott Draves}
\maketitle

% $Id: manual.latex,v 1.3 1992/06/22 15:53:54 mas Exp $

\newcommand{\eval}{$\;\Rightarrow\;$}
\newcommand{\eequiv}{$\;\equiv\;$}
\newcommand{\h}{\char'136\relax}
\newcommand{\w}{\char'137\relax}
\newtheorem{bug}{Bug}
\newtheorem{cav}{Caveat}

% fix bug in psfonts.sty

\makeatletter
\def\@circumflex{\char'323\relax}
\def\@tilde{\char'322\relax}
\makeatother

\section{Introduction}

This document serves as a description of fnord version 1.1 as seen by
a user.  Its primary goal is to be comprehensive rather than tutorial.
If you are trying to learn the fnord language, your best hope is
probably to read Section~\ref{Overview}, then study some real code,
and to read the rest only after you understand the basics well.

This document does not describe the internals of the interpreter or
visualization system.  We present very little motivation of or
exposition on the ideas behind fnord.  This is not a scholarly work;
it has no references.

We start out with an overview that includes highlights from the
syntax, and some examples.  The syntax is described in
Section~\ref{Syntax}.  Then we cover values and types.
Section~\ref{The Operators} is the largest section; it lists all the
operators and what they do.  Next, the operation of the interpreter is
described.  Section~\ref{Visualization} describes the visualization system.
Finally the standard library is explained in
Section~\ref{Standard Library}.

\subsection{What Fnord is Not}

Fnord is not a traditional symbolic algebra program like MACSYMA or
Mathematica.  Fnord does not factor polynomials, solve equations,
or integrate expressions.  Fnord is not meant to be an algebraic
assistant.

\subsection{What Fnord Is}

Fnord has two primary components.  It contains a programming language
(named fnorse).  It contains a user interface and visualization
system.  A user describes mathematical objects, usually curves,
surfaces, or other geometry, in the fnorse language.  An interpreter
computes the objects from the descriptions, and passes them to the
visualization system where they are displayed.

A typical fnorse program may create a parametric function and a
domain, and then display the surface that results from applying the
function to the domain.

Fnorse programs may contain constants whose values are generated by
interactive widgets.  When a widget is manipulated its value changes
and the objects affected by that widget are recomputed and displayed.

\subsection{Typographical Conventions}

We use the {\tt typewriter} typeface for all input and output from the
interpreter.  The {\sf sans-serif} typeface is used for the names of
operators.  We use an arrow to show evaluation {\tt 1 + 1}\eval{\tt
2}.  The three-lined equals denotes equivalence: {\tt x +
-y}\eequiv{\tt x - y} means the two expressions will have the same
value regardless of the bindings of {\tt x} and {\tt y}.

\section{Overview}
\label{Overview}

Before going into detail, we state the major features of the fnorse
language, and give a few examples.

\begin{itemize}

\item Fnorse is purely functional.  That means that no operator has
any side effects; there is no assignment operator.  A function does
nothing but compute its return value.

\item All user functions take one argument and return one value.  This
is usually hidden from the user because the lambda operator
automatically deconstructs its argument and binds its components to
separate symbols.

\item Functions are first-class objects; they may be created, passed
to other functions, and evaluated.  This is also called support for
``higher order functions''.

\item Fnorse is optionally typed, and a limited form of type
inferencing is performed.  This means that functions and objects may
be declared either with or without a type. Types may contain type
variables that match anything; they may be {\em type schemas}.

\end{itemize}

\subsection{Basic Syntax}
A few notes about the syntax (parenthetical comparisons are to Scheme):
\begin{itemize}

\item Parentheses are used only to indicate grouping.  They do not
indicate function calls.

\item  Functions are invoked by juxtaposition, e.g.  {\tt f x}.  Since
parentheses only indicate grouping, {\tt f(x)} also is a function
call; this is the usual syntax.  If the left object is not a function,
then it is multiplied instead; e.g. {\tt 2x}.

\item  Symbols are defined with {\tt :=} (like {\sf define}),
functions created with {\tt ->} (like {\sf lambda}).  Definitions are
terminated with {\tt ;}.  Thus {\tt f := x -> x + 1;} binds {\tt f} to
a function which adds one, after which {\tt f(2)}\eval{\tt 3}.

\item  Comma creates pairs (infix {\sf cons}).  It is an infix
operator like any other.  {\sf left} and {\sf right} extract parts of
pairs (like {\sf car} and {\sf cdr}).  Pairs are usually parenthesized
because comma has low precendence.  Thus {\tt (1, 2)} is a pair of
integers.

\item  Vectors and matrices are created with square brackets.
{\tt [1, 2, 3]} is a vector of three integers; {\tt [[1, 2],[3, 4]]}
is a two by two matrix.  Sets can be created with curly braces.
{\tt \{1, 2, 3\}} is a set containing three integers.

\item  Entries are extracted from vectors with hat, so
{\tt [a, b]\h 1}\eequiv{\tt a}.  The same goes for
matrices, so if {\tt a := [[1, 2], [3, 4]]}, then
{\tt a\h 1}\eval{\tt [1, 2]} and
{\tt a\h 2\h 1}\eval{\tt 3}.
\end{itemize}

\subsection{Simple Examples}

\begin{figure}
\begin{verbatim}
X := R^2    -> R^3
  :  [u, v] -> [sin(u) cos(v), 
                cos(u) cos(v),
                sin(v)]
  ;
U := Patch((-pi, pi, 40),
           (-pi/2, pi/2, 20));
widget Show(X(U));
\end{verbatim}
\caption{Create and display a sphere.}
\label{fig:sphere}

\centerline{\psfig{figure=sphere.ps,width=2in}}
\caption{The Sphere}
\label{fig:spherepict}

\end{figure}

\begin{figure}
\begin{verbatim}
int := Z;
F := int -> int -> int
  :  x   -> y   -> x y
  ;
A := {1, 2, 3};
print F 7 A;
=> {Z} : {7, 14, 21}
print F A 7;
=> {Z} : {7, 14, 21}
print F A A;
=> {Z} : {1, 2, 3, 
          2, 4, 6,
          3, 6, 9}
print F A;
=> {(Z -> Z)} : {fn}
\end{verbatim}
\caption{Functions and sets.}
\label{fig:FuncsAndSets}
\end{figure}

Figure~\ref{fig:sphere} generates and displays a sphere.  {\tt X} is a
typed function from the plane to space.  {\tt U} is a rectangular
subset of the plane; it is sampled in a regular grid, forty samples by
twenty.  The type of {\tt U} is {\tt \{R\h 2\}} ($U \subset R^2$, or
$U \in 2^{R^2}$).  When {\tt X} is applied to {\tt U}, the interpreter
sees that the domain of {\tt X} does not match the type of {\tt U}.
So it applies {\tt X} to each point of {\tt U} instead.

The functions {\tt Patch} and {\tt Show} (and even the symbol {\tt R})
are part of the standard library, and are defined in terms of language
primitives.

The code in Figure~\ref{fig:FuncsAndSets} shows how functions and sets
interact.  {\tt F} is the curried multiply function.  {\tt F A} is the
set of functions which multiply by 1, 2, and 3.  Just as a function
applied to a set can map over the elements of the set, a set of
functions applied to an object applies each of the functions to the
object.  Thus {\tt F A 7} makes sense and is {\tt {7, 14, 21}}.
Lastly, a set of functions applied to a set performs an
outer-product-like operation, resulting in all combinations of
products.  If we ask it to print out just {\tt F A}, only {\tt \{fn\}}
appears.  This is because functions have no print form.

Here we end our quick overview and begin the comprehensive
description, starting with the syntax of fnorse.

\section{Syntax}
\label{Syntax}

Fnorse syntax is based upon common mathematical notation.
A fnorse program consists of a sequence of statements.
There are four kinds of statements: declarations, widget
declarations, commands, and interpreter directives.  All
statements are terminated by a semicolon.

\begin{itemize}

\item A declaration has the form {\em identifier} {\tt :=} {\em
expression} {\tt ;}.

\item A widget declaration either has the form {\em identifier} 
{\tt := widget} {\em expression} {\tt ;}, or just {\tt widget} {\em
expression} {\tt ;}.  See Section~\ref{Visualization}.

\item A command has the form {\em command} {\em expression}
{\tt ;} The commands and their meanings are described in
Section~\ref{Commands}

\item An interpreter directive has the form {\em directive}{\tt ;}.  The
directives and their meanings are described in section
\ref{Directives}.

\end{itemize}

\subsection{Comments}

Comments are C-style, but they may be nested.  Comments break up other
tokens; removing a comment is more akin to replacing it with
whitespace than to removing exactly its characters.  See
Figure~\ref{fig:comments}.

\begin{figure*}
\begin{verbatim}
MakeCylinders  /* this is the name /* of */ the function */
   := R^3    -> R^2    -> R^3   /* this is the type */
   :  center -> [u, v] ->  center + [sin(u), cos(u), v]
   ;  /* we end the definition with a semi-colon */
\end{verbatim}
\caption{Example of Comments.}
\label{fig:comments}
\end{figure*}

\subsection{Literals}

There are four sorts of literals recognized by the lexer:
identifiers, integers, reals, and strings.

\subsubsection{Identifiers}

Fnorse identifiers are case sensitive.  They consist of
digits and letters, and must start with a letter.  By
convention, the first letter of each word of multi-word
identifiers is in upper case.  Thus {\tt Append},
{\tt GaussianCurvature}, and {\tt a1} are identifiers
while {\tt my\w func}, {\tt my-func}, and {\tt 1a} are
not.

Identifiers also may not be one of the reserved words (see
Table~\ref{table:ReservedWords}), or one of the built-in functions
(see Section~\ref{Built-In Functions}).

\begin{table}
\begin{center}
\begin{tabular}{|l|}
\hline
{\tt and} \\
{\tt be} \\
{\tt debug} \\
{\tt else} \\
{\tt eval} \\
{\tt if} \\
{\tt in} \\
{\tt let} \\
{\tt mod} \\
{\tt not} \\
{\tt print} \\
{\tt or} \\
{\tt union}  \\
{\tt widget} \\
\hline
\end{tabular}
\end{center}
\caption{Reserved words.}
\label{table:ReservedWords}
\end{table}

\subsubsection{Integers}

An integer is a sequence of digits.  All integers are interpreted in
base ten.  A sign may be placed in front of an integer, but it is not
part of it.  Such a sign is really an operator applied to the integer;
thus all literal integers are non-negative.

The value of an integer is the best representation the machine can
make of that integer.  This will generally be a signed 32 bit value,
i.e. -2147483648 to 2147483647.

\subsubsection{Reals}

Real numbers have a more complicated syntax; one best described by a
few examples.  See Table~\ref{table:reals}.

\begin{table}
\begin{center}
\begin{tabular}{|l|l|}
\hline
reals & not reals \\
\hline
{\tt 1.1} & {\tt 1} \\
{\tt .1} & {\tt 1.} \\
{\tt 1e5} & {\tt 1 e5} \\
{\tt 1.1E-5} & \\
{\tt .1e+5} & \\
\hline
\end{tabular}
\end{center}
\caption{Valid and invalid real numbers.}
\label{table:reals}
\end{table}

The value of a real is the real.  Again, only the best machine
representation will be used.  This is usually IEEE double precision
floating point, but it may be single precision, or anything else.

\subsubsection{Strings}

Strings are started and terminated by double quotes \verb$"$.  No
escapes are supported; everything between the quotes is taken
verbatim.

The value of a string is a vector of integers, where the integers are
the ASCII codes of the characters in the string.  Thus \verb$"hi mom"$
\eval{\tt Z\h 6: [104, 105, 32, 109, 111, 109]}.  They are used
primarily as parameters to widgets.

\subsection{Expressions}
\label{Expressions}

Because fnord is a functional language, nearly all of its syntax (and
semantics) is connected to expressions.  All expression syntax is
listed in Table~\ref{table:operators2}.  The operators are classified
as unary prefix, unary postfix, binary infix, and ternary infix, and
atomic.  Each operator has precedence and associativity.  There are
some special cases, which are described below.  The table lists all
the operators with syntax, their class, syntax, and associativity (for
infix binary).  The table is from highest to lowest precedence,
horizontal lines seperate groups of equal precedence.

\begin{table*}
\begin{center}
\begin{tabular}{|lllll|}
\hline
name & class & syntax & associates & section \\
\hline \hline
 &  & {\tt (x)} & & \\
{\sf set} & atomic & {\tt \{x\}} &  & \ref{Set Ops} \\
{\sf null-set} &  atomic & {\tt \{ \}} &  & \ref{Set Ops} \\
{\sf vector-build} & atomic & {\tt [x]} & & \ref{Vectors} \\
{\sf implicit} & atomic & {\tt \{x in y | z\}} & & \ref{Implicit} \\
{\sf blank} & atomic & {\tt ?} & & \ref{Blank} \\
\hline
{\sf quote} & prefix & {\tt `x} & & \ref{Quote} \\
\hline
{\sf prime} & postfix & {\tt x'} & & \ref{Prime} \\
{\sf factorial} & postfix & {\tt x!} & & \ref{Factorial} \\
\hline
{\sf row-extract} & infix & {\tt x\w y} & left & \ref{Vectors} \\
{\sf column-extract} & infix & {\tt x\h y} & left & \ref{Vectors},
\ref{Power} \\ 
\hline
{\sf power} & infix & {\tt x**y} & right & \ref{Power} \\
\hline
{\sf apply} & infix & {\tt x(y)} & left & \ref{Apply} \\
\hline
{\sf apply} & infix & {\tt x y} & left & \ref{Apply} \\
\hline
{\sf cardinality} & prefix & {\tt \#x} & & \ref{Cardinality} \\
{\sf opposite} & prefix & {\tt -x} & & \ref{Arithmetic} \\
 & prefix & {\tt +x} & & \\
{\sf not} & prefix & {\tt not x} & & \ref{Logical} \\
\hline


% \end{tabular}
% \end{center}
% \caption{Operators with Special Syntax.  This is the top half the the
% table.}
% \label{table:operators1}
% \end{table*}

% \begin{table*}
% \begin{center}
% \begin{tabular}{|lllll|}
% \hline
% name & class & syntax & associates & section \\
% \hline \hline
{\sf modulo} & infix & {\tt x mod y} & left & \ref{Arithmetic} \\
{\sf cross} & infix & {\tt x >< y} & left & \ref{Vector Cross},
\ref{Set Cross} \\
{\sf dot} & infix & {\tt x . y} & left & \ref{Dot Product} \\
{\sf times} & infix & {\tt x * y} & left & \ref{Arithmetic} \\
{\sf divided-by} & infix & {\tt x / y} & left & \ref{Arithmetic} \\
{\sf concatenate} & infix & {\tt x :: y} & left & \ref{Vectors} \\
\hline
{\sf plus} & infix & {\tt x + y} & left & \ref{Arithmetic} \\
{\sf minus} & infix & {\tt x - y} & left & \ref{Arithmetic} \\
\hline
{\sf equal} & infix & {\tt x = y} & left & \ref{Relops} \\
{\sf exactly-equal} & infix & {\tt x === y} & left & \ref{Relops} \\
{\sf not-equal} & infix & {\tt x != y} & left & \ref{Relops} \\
{\sf less-than} & infix & {\tt x < y} & left & \ref{Relops} \\
{\sf greater-than} & infix & {\tt x > y} & left & \ref{Relops} \\
{\sf less-or-equal} & infix & {\tt x <= y} & left & \ref{Relops} \\
{\sf greater-or-equal} & infix & {\tt x >= y} & left & \ref{Relops} \\
\hline
{\sf and} & infix & {\tt x and y} & left & \ref{Logical} \\
{\sf or} & infix & {\tt x or y} & left & \ref{Logical} \\
\hline
{\sf union} & infix & {\tt x union y} & left & \ref{Union} \\
{\sf enumerate} & infix & {\tt x..y} & left & \ref{Enumerate} \\
{\sf if} & infix & {\tt x if y} & left & \ref{Conditionals} \\
{\sf if-else} & ternary & {\tt x if y else z} & left & \ref{Conditionals} \\
{\sf let} & ternary & {\tt let x be y in z} & left & \ref{Let} \\
\hline
{\sf lambda} & infix & {\tt x -> y} & right & \ref{Lambda} \\
\hline
{\sf cast} & infix & {\tt x : y} & left & \ref{Cast} \\
\hline
{\sf a-list-pair} & infix & {\tt x <- y} & left & \ref{Associations} \\
\hline
{\sf pair} & infix & {\tt x, y} & left & \ref{Pairs} \\
\hline
\end{tabular}
\end{center}
\caption{Operators with Special Syntax.}
\label{table:operators2}
\end{table*}

Notice that {\sf apply} appears twice.  The higher precedence {\sf
apply}, sometimes called {\sf p-apply}, exists because without it {\tt
sin(x) cos(x)} would associate {\tt ((sin x) cos) x} rather than {\tt
(sin x)(cos x)}.

The relational operators are a special case.  When they are chained
together, {\sf and} nodes are added between the pairs.  Thus {\tt (x <
y < z)}\eequiv{\tt (x < y and y < z)} and {\tt (x = y > z)}\eequiv{\tt
(x = y and y > z)}.

The {\sf if-else} operator is meant to be chained like this:
\begin{verbatim}
F := x -> -1 if  x < -1 else
           x if  x <  1 else
           1
  ;
\end{verbatim}

\subsection{Built-In Functions}
\label{Built-In Functions}

Besides the operators with special syntax there are a number of
built-in functions.  These all have the same syntax: {\em name
arguments}.  For example, {\tt sin x}, and {\tt binomial(x, y)}.  The
built-in functions are listed in Table~\ref{table:built-ins2}.

\begin{cav}
The built-in functions differ from user functions in that they do not
all take one argument.  Those that take two (or more) arguments must
be supplied with exacly two (or more) arguments.  For example, {\tt a
:= (3, 4); b := binomial(a)} is an error, as is {\tt f := sin; b :=
f(1);}.

This is a serious problem, and can be somewhat alleviated by defining
wrappers around the build-in functions.  It is not practical in some
cases, however.
\end{cav}

\begin{table}
\begin{center}
\begin{tabular}{|ll|}
\hline
name & section \\
\hline
{\sf acos}  & \ref{scalarOps} \\
{\sf acosh}  & \ref{scalarOps}  \\
{\sf asin}  & \ref{scalarOps} \\
{\sf asinh}  & \ref{scalarOps} \\
{\sf atan}  & \ref{scalarOps} \\
{\sf atanh}  & \ref{scalarOps} \\
{\sf assoc}  & \ref{Associations} \\
{\sf binomial}  & \ref{Binomial} \\
{\sf bitand}  & \ref{bitops} \\
{\sf bitnot}  & \ref{bitops} \\
{\sf bitor}  & \ref{bitops} \\
{\sf bitxor}  & \ref{bitops} \\
{\sf complex}  & \ref{cxandb} \\
{\sf cos}  & \ref{scalarOps} \\
{\sf cosh}  & \ref{scalarOps} \\
{\sf cxfrag}  & \ref{cxandb} \\
{\sf exp}  & \ref{scalarOps} \\
{\sf fragment}  & \ref{Vectors} \\
{\sf identity}  & \\
{\sf implicit} & \ref{Implicit} \\
{\sf interval} & \ref{Interval} \\
{\sf left}  & \ref{Pairs} \\
{\sf log} & \ref{scalarOps} \\
{\sf min} & \ref{MinMax} \\
{\sf max} & \ref{MinMax} \\
{\sf nop} & \\
{\sf polynomial}  & \ref{polynomial}\\
{\sf realtoint}  & \\
{\sf reduce} & \ref{Reduce} \\
{\sf right}  & \ref{Pairs} \\
{\sf sample}  & \ref{Sample} \\
{\sf sin}  & \ref{scalarOps} \\
{\sf sinh}  & \ref{scalarOps} \\
{\sf spew}  & \\
% \hline
% \end{tabular}
% \end{center}
% \caption{The Built-In Functions.  This is the first half of the
% table.}
% \label{table:built-ins1}
% \end{table}

% \begin{table}
% \begin{center}
% n\begin{tabular}{|ll|}
% \hline
% name & section \\
% \hline
{\sf sqrt}  & \ref{scalarOps} \\
{\sf square}  & \\
{\sf tan}  & \ref{scalarOps} \\
{\sf tanh}  & \ref{scalarOps} \\
{\sf triangle}  & \ref{Triangle} \\
{\sf type}  & \ref{typeop} \\
{\sf typematch}  & \ref{typematch} \\
{\sf typematchx}  & \ref{typematch}\\
{\sf zero} & \\
\hline
\end{tabular}
\end{center}
\caption{The Built-In Functions.}
\label{table:built-ins2}
\end{table}

\section{Values and Types}

Values fall into four classes, independent of the type system.  The
four classes are bare, set, symbol, and type.

\subsection{Bare}

Bare values in fnord correspond to the values of most other
programming languages.  Here are such common constructions as
integers, vectors, and pairs.

A bare value may be a member of one of the {\em base domains}, or it
may be a composite value.  The base domains are booleans, integers,
reals, complexes, and maps.  The first four are straightforward.  A
map is a function expressed in fnorse.  Maps are created by the lambda
operator (Section~\ref{Lambda}).  Other languages refer to maps as
closures.

A composite value is either a pair of two bare values (see section
\ref{Pairs}), or a vector of bare values (see Section~\ref{Vectors}).

\subsection{Sets}
\label{Set Values}

Where bare value are elements of the base and composite domains, fnord
sets are subsets of the base and composite domains.

A set is an unordered, heterogeneous collection of bare values.
``unordered'' means there is no first element of a set, and there is
no natural correspondence between the elements of two sets, even if
they have the same number of elements.  ``Heterogeneous'' means the
elements of a set may be of different types.  Sets may contain the
same element more than once.  Fnord sets may be continuous, that is, a
set might be all the real numbers between 0 and 1, inclusive.  It is
even possible to have continuous sets in function spaces.

A set has two parts: samples and connectivity.  A continuous set is
represented by a piece-wise linear approximation.  The elements of the
set are always barycentric linear combinations of the samples.  The
connectivity controls which samples may be combined.  For finite sets
the samples are the elements of the set and the connectivity is
discrete; no samples may be combined.

For example, a continuous curve is represented by an array of points
(the samples) and the note that these points are to be connected, each
to the next, by straight line segments (the connectivity).

Because all the elements of a set are either enumerated, or are
between two other elements, all sets are closed, bounded subsets in
the mathematical sense.

\subsubsection{Blocks}

The samples of a set are divided into blocks.  Each block has
homogeneous type and a regular pattern of connectivity.  Samples from
different blocks are never connected.

\subsubsection{Connectivity}
\label{Connectivity}

The samples of each block are connected in a regular pattern.  These
patterns are based on $n$-dimensional meshes.  The number of
dimensions is the {\em rank} of the block.  If you think of the block
as a $n$-manifold enbedded in $m$-space, then the rank of the block is
usually (unless some of its coordinates are discrete or triangular)
$n$.  $m$ depends on the type of the set.

Each coordinate of the rank has the following information: an integer,
the discrete/connected flag, and the linear/triangular flag.  For now,
ignore the triangular flag, that will be explained later.

The integer is the numbers of samples along that coordinate of the
mesh.  The discrete/connected flags tell whether or not the samples of
the mesh are connected in that coordinate.  Some examples are in
order, see Figure~\ref{fig:LinearConnectivity}

\begin{figure}
\begin{enumerate}

\item rank 1, [(3, connected, linear)], \\ {\tt I(0, 1, 3)}

\centerline{\psfig{figure=connectivity-3cl.eps,width=2in}}

\item rank 1, [(6, discrete, linear)], \\ {\tt S(I(0, 1, 6))}
\label{linear:discreteA}

\centerline{\psfig{figure=connectivity-6dl.eps,width=2in}}

\item rank 2, [(3, connected, linear), (2, connected, linear)], \\
{\tt [I(0, 1, 3) >< I(0, 1, 2)]}

\centerline{\psfig{figure=connectivity-3cl-2cl.eps,width=2in}}

\item rank 2, [(3, connected, linear), (2, discrete, linear)], \\ 
{\tt [I(0, 1, 3) >< S(I(0, 1, 2))]}

\centerline{\psfig{figure=connectivity-3cl-2dl.eps,width=2in}}

\item rank 2, [(3, discrete, linear), (2, discrete, linear)], \\
{\tt [S(I(0, 1, 3)) >< S(I(0, 1, 2))]}
\label{linear:discreteB}

\centerline{\psfig{figure=connectivity-3dl-2dl.eps,width=2in}}

\end{enumerate}
\caption{Linear connectivity.  For each example the rank is given,
followed by the samples and flags for each coordinate, followed by
code generates a set with that connectivity.  In this code {\tt S} is
an abbreviation for {\tt sample} and {\tt I} for {\tt Interval}.}
\label{fig:LinearConnectivity}
\end{figure}

Note that examples \ref{linear:discreteA} and \ref{linear:discreteB}
represent identical connectivities.  Both are discrete.

The triangular flag is rather strange.  The number of samples for this
coordinate is now $n(n+1)/2$ if $n$ is the integer.  The samples are
connected in a triangular mesh; see
Figure~\ref{fig:TriangularConnectivity}.

\begin{figure}
rank 1, [(3, connected, triangular)], \\ {\tt triangle([[0, 0], [1,
0],[0.5, 1]], 3)}

\centerline{\psfig{figure=connectivity-3ct.eps,width=2in}}

\caption{Triangular connectivity.}
\label{fig:TriangularConnectivity}
\end{figure}

The total number of samples in a block is the product of the number of
samples for each coordinate.  The total dimension (the $n$ in
$n$-manifold) is the sum of the contributions of the coordinates.
Discrete coordinates contribute zero, connected linear coordinates
contribute one, and connected triangular coordinates contribute two.
Thus a block with connectivity [(4, connected, triangular), (3,
discrete, linear), (2, connected, linear)] has 60 samples and is a
3-manifold.

\subsection{Symbols}

A value may be a symbol.  These can only be created with the quote
operator, see Section~\ref{Quote}.

\subsection{Type Values}

Types are first-class objects, and therefore may be the values of
expressions.  Some operators work differently when their operands are
types, see Section~\ref{TypeOperators}.

\subsection{Types of Values}

The type system is odd.  Talk about it in general.  List the
constructors they correspond to. Make a ref to Section~\ref{TypeOperators}.

Non-homogenious sets get assigned the type {\tt \{?\}}.  There is no
way to construct a type that corresponds to ``sets containing some
reals and some integers'', for example.

Types can have {\em blanks} in them.  Such a type is really a type
schema, but fnord doesn't treat them any differently.  A blank has
syntax {\tt ?}.  The length of a vector may also be a blank, and has
the same syntax.  For example {\tt (Z, R\h ? -> \{?\})} represents the
type of a pair of an integer and a function from vectors of reals of
any length to sets of anything.

Blanks are like type variables, with each blank standing for a
different variable.  This means that pattern matching rather than
unification can be used to type check and cast values.

\section{The Operators}
\label{The Operators}

This section is a catalogue of all the operators in the fnord
language.  For each operator we give the syntax, what it does, and the
{\em expected type} of each argument.  The expected type is described
in Section ~\ref{expectedtype}.

\subsection{Fundamental Operators}

\subsubsection{Lambda}
\label{Lambda}

{\sf lambda} creates functions.  It does not evaluate its arguments.
Its syntax is {\tt x -> y}.

Within the lexical scope of the {\sf lambda}, the symbols on the left
are bound to different parts of the argument ({\em the} argument
because user functions have exactly one argument).  For example, when
{\tt (x, y) -> x + 2y} is applied to a pair, {\tt x} is bound to the
{\sf left} of the pair, and {\tt y} to the {\sf right}.  It would be
an error if the argument weren't a pair.

Basically, the left side of the {\sf lambda} is a pattern which is
matched against the argument.  Each symbol is bound to the the part of
the argument that it matches.  A more complicated example: if {\tt f
:= [x, y] -> x + y;} then in {\tt f[1, 2]}, {\tt x} is bound to {\tt
1}, and in {\tt f[[1, 2], [3, 4]]}, {\tt x} is bound to {\tt [1, 2]}.

The type of the resulting function is {\tt ? -> ?}.  Use {\sf cast} to
get a more specific type.  {\sf Lambda} is also a type operator, see
section \ref{TypeOperators}.

\subsubsection{Apply}
\label{Apply}

{\sf Apply} evaluates functions on points.  It can also represent
multiplication.  Its syntax is juxtaposition: {\tt x y}.  {\sf Apply}
is one of the most complex operators; it has some special
functionality.

{\sf Apply} evaluates its arguments as usual.  If the expected type of
{\sf apply} is {\tt A} then the expected type of the for the left
argument is {\tt ? -> A}, and the expected type of the right argument
is {\tt ?}.

Currently, the way {\sf apply} works isn't entirely pretty, but it
does ``do the right thing.''  When a set of functions is applied to an
object, the result may depend on how the set was created.  Its
behavior is described in Table~\ref{apply cases}.

In summery, functions map over sets, and a set of functions maps over
a value.  When a set of functions is applied to a set, there are two
possibilities:

\begin{itemize}
\item Each function is applied to each point.  The resulting points
are placed in a set.  This is what happens when the set of functions
was created with a curried function.
\item Each function is applied to the set.  The results of these
applications are placed in a set.  This happens when the set of
functions was created explicitly.
\end{itemize}

\begin{table*}
\begin{center}
\begin{tabular}{|llllll|}
\hline
left type & right type & action & result type & example & result \\
\hline
{\tt N} & {\tt B} & multiply & {\tt N} & {\tt 2 3} & {\tt 6} \\
{\tt A -> B} & {\tt A} & simple-apply & {\tt B} & {\tt f 2} & {\tt 6} \\
{\tt A -> B} & {\tt \{A\}} & right-map & {\tt \{B\}} & {\tt f \{2, 3\}} &
{\tt \{6, 9\}} \\
{\tt \{A -> B\}} & {\tt A} & left-map & {\tt \{B\}} &  
{\tt \{f, g\}2} & {\tt \{6, 4\}} \\
{\tt \{A -> B\}} & {\tt \{A\}} & outer-product & {\tt \{B\}} & 
{\tt G \{2, 3\} \{2, 3\}} &  {\tt \{4, 6, 6, 9\}} \\
{\tt \{A -> B\}} & {\tt \{A\}} & double-map & {\tt \{\{B\}\}} &  
{\tt \{f, g\}\{2, 3\}} & {\tt \{\{4, 6\}, \{6, 9\}\}} \\
\hline
\end{tabular}
\end{center}
\begin{center}
\begin{tabular}{|ll|}
\hline
symbol & denotes \\
\hline
{\tt N} & any non-functional type \\
{\tt A}, {\tt B} & any type \\
{\tt f} & {\tt f := Z -> Z : x -> 3 * x} \\
{\tt g} & {\tt g := Z -> Z : x -> 2 * x} \\
{\tt G} & {\tt G := Z -> Z -> Z : x -> y -> x * y} \\
\hline
\end{tabular}
\end{center}
\caption{{\sf Apply}'s Cases.}
\label{apply cases}
\end{table*}

See Figure~\ref{tetra} for an example of using the outer product
apply.

\begin{figure*}
\begin{verbatim}
Tetrahedron := 
  ([[-1, -1, -1], [ 1,  1, -1], [-1,  1,  1], [ 1, -1,  1]],
   {[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]})
  ;

makeEdges
  := R^?^? -> Z^2  -> R -> R^?
  :  verts -> edge -> t -> t verts^(edge^1) + (1-t)verts^(edge^2)
  ;

Polygon
  := (R^?^?, {Z^2}) -> {R^?}
  :  (verts, edges) -> (makeEdges verts edges)(Interval(0, 1, 2))
  ;

widget Show(Polygon(Tetrahedron));
\end{verbatim}
\caption{Code that makes use of outer-product apply.  The edges have
only two samples because we know they are straight.  If you wanted to
non-linearly deform the polygon, you would use a larger value.}
\label{tetra}
\end{figure*}
\begin{figure}
\centerline{\psfig{figure=tetra.ps,width=2in}}
\caption{The Tetrahedron.}
\end{figure}

After substituting and evaluating, the result is cast to the codomain
part of the function's type.  Thus {\tt (R -> R : x -> x)(Z :
1)}\eval{\tt R : 1.0}.  Note that the right argument to {\sf apply} is
{\em not} cast to the domain type before it is substituted.  Thus {\tt
(R -> ? : x -> type x)(1)}\eval{\tt type Z}.  This is becuase many
operations are faster on integers than on real numbers (ditto for
reals and complexes), so it is better to cast as late as possible.

\begin{bug}
If a constant valued function is applied to a set of objects, then the
result is a bogus value.  This value will behave properly most of the
time, but not always.  Try, for example,
\begin{verbatim}
F := R -> Z : x -> 1;
A := Interval(0, 1, 10);
f := (x, y) -> x + y;
print reduce(F(A), f, 0);
\end{verbatim}
\end{bug}

\subsubsection{Let}
\label{Let}

{\sf Let} has syntax {\tt let x be y in z}.  It is pure syntactic
sugar; the usual combination of {\sf lambda} and {\sf apply} is used.
Thus {\tt let x be y in z}\eequiv{\tt (x -> z)(y)}.  It is normally
used to reduce redundant code, a manual form of common subexpression
elimination.  For example,
\begin{verbatim}
Fpq := (R^3, R^3) -> R^3
    :  (p, q) ->
             let dist be Length(p - q) in
             let none be [0, 0, 0] in
             none if dist > diam else
             none if dist = 0 else
             (diam - dist) * (p-q) / dist
    ;
\end{verbatim}

It can also be used to break a stucture into smaller components, as in
\begin{verbatim}
F := R^3 -> R^3
  :  v   -> let [x, y, z] be v in
            [x y, y z, z x] / (v . v)
  ;
\end{verbatim}

Multiple symbols can be bound either by binding a tuple, or by
chaining several {\sf let} operators together.

\subsubsection{Cast}
\label{Cast}

{\sf Cast} makes sure an expression has a particular type.  It has
syntax {\tt x : y}.  The left argument is expected to be a type.  The
right argument is evaluated with this type as its expected type.  It
is then cast to the type.

{\sf Cast} has two main uses.  First, when declaring a function it is
used to declare the function's type.  Thus evaluating {\tt R -> R : x
-> 2x}\eval{\tt R -> R : fn}, whereas just {\tt x -> 2x}\eval{\tt ? ->
?  : fn}.  A specific type is required if a function is to be
differentiated (see Section~\ref{Prime}), or map over sets (see
Section~\ref{Apply}).

The other main use is to cast a scalar up the domain chain.  Thus {\tt
R : 1}\eval{\tt R : 1.0} and {\tt C : 1}\eval{\tt C : 1.0 + 0.0i}.

{\sf Cast} accepts types with blanks in them.  Thus {\tt (R, ?)  : (1,
2)}\eval{\tt (R, Z) : (1.0, 2)} and {\tt R\h ? : [1, 2]}\eval {\tt
R\h}{\tt 2 : [1.0, 2.0]}.

\begin{bug}
Casting down should be an error; instead it produces bogus objects.
For example, {\tt (Z : 1.1)}\eval{\tt (Z : 1.1)}.
\end{bug}

\subsection{Constructors and Destructors}

Define constructors and destructors.  What the hell is
their definition anyway?

\subsubsection{Pairs}
\label{Pairs}

{\sf Pair} creates the the analog of LISP's cons cells.  Any two
objects may form a pair.  Pairs are deconstructed with {\sf left} and
{\sf right} (LISP's {\sf car} and {\sf cdr}).  The syntax for {\sf
pair} is {\tt x, y}.  {\sf Left} and {\sf right} are built-in
functions.

A {\em pair-tree} is a value that is not a pair (an atom in LISP), or
is a pair of pair-trees.  A pair-tree has {\em leaves}, which are the
values from which it was created.  Leaves are never pairs.  For
example, {\tt (1, 2, 3)} is a pair-tree whose leaves are the integers
1, 2, and 3.  {\tt ((1, 2), (1.1, x -> (x, x)))} is a pair-tree with
four leaves.  {\tt True} is a pair-tree with one leaf.  A pair-tree
that is left-associated is called {\em flat}.  The leaves of a
pair-tree are ordered by an in-order traversal of the tree, this is
the same order they appear in if the pair-tree was created as the
above examples were.

Pair-trees with the same leaves might have different representations.
For example, {\tt ((1, 2), 3)} and {\tt (1, (2, 3))} have the same
leaves in the same order, but they are structured differently.
Whenever we say an operator works with the leaves of a pair-tree, we
mean that the structure of the pair-tree is ignored.  The structure is
important to some operators.

{\sf Pair}, {\sf left}, and {\sf right} are all type operators, see
section \ref{TypeOperators}.

\subsubsection{Sets}
\label{Set Ops}

Sets are modeled after their mathematical namesake.  See section
\ref{Set Values} for a precise description.  Sets are unusual because
there are no destructors\footnote{{\sf Reduce} could be considered a
destructor of sorts, see Section~\ref{Reduce}.}.

There are two seperate operators for creating sets, which appear
almost the same: {\sf set} and the {\sf null-set}.  The syntax for
{\sf set} is {\tt \{x\}}.  Its argument is a pair-tree.  The elements
of the created set are the leaves of the pair-tree.  Such sets have
discrete connectivity, see Section~\ref{Connectivity}.

\begin{cav}
Because the elements are the leaves of a pair-tree, it is difficult to
explicitly create a set with elements that are pairs.  There are two
ways to do it, however:
\begin{itemize}
\item A product of singleton sets, for example {\tt \{1\} >< \{2\}}
creates a set containing the pair {\tt (1, 2)}.
\item Use a function like 
\begin{verbatim}
PairSet
   := (?, ?) -> {?}
   :  p      -> (Z -> ? : n -> p){1}
   ;
\end{verbatim}
\end{itemize}
\end{cav}

{\sf null-set} has syntax {\tt \{ \}}.  It creates a set with no
elements.

{\sf Set} is a type operator, see Section~\ref{TypeOperators}.  There
are other ways of creating sets, see Section~\ref{Interval}.

\subsubsection{Vectors}
\label{Vectors}

Vectors are also modeled after their mathematical namesakes, but more
closely.  A vector has some number of entries.  Each entry can be any
object, but they all must be the same type.  The number of entries is
the {\em dimension} of the vector.

Vectors are created in much the way sets are, {\sf vector-build} has
syntax {\tt [x]}.  The vector created has entries that are the leaves
of pair-tree {\tt x}.

\begin{cav}
Because the leaves of a pair-tree are used, vectors cannot have
entires that are themselves pairs.  This causes problems (see
Section~\ref{Prime}).
\end{cav}

Vectors are similar to pair-trees because both are ordered finite
collections of other values.  The primary difference is that the
entries of a vector must be all the same type, whereas the leaves of a
pair-tree may have any types.

There are two ways to destruct vectors.  {\sf Fragment} converts a
vector to a pair-tree whose leaves are entries of the vector.  The
pair-tree will be flat.  Thus {\tt fragment[x, y, z]}\eequiv{\tt ((x,
y), z)}.  Users rarely invoke this operator directly, instead it is
generated by {\sf lambda}, see Section~\ref{Lambda}.  {\sf fragment}
is a built-in function.

{\sf Vector-build} maps over sets.  Thus {\tt [\{1, 2, 3\}]}\eval{\tt
\{[1], [2], [3]\}}.

{\sf Column-extract} has syntax {\tt x\h y}.  {\tt x} is a vector, and
{\tt y} is an integer index.  Vector entries are indexed from one.
Thus {\tt [x, y]\h 1}\eequiv{\tt x}.  Using an out-of-range index is
an error.

{\sf Concatenate} has syntax {\tt x :: y}.  It is defined by {\tt x ::
y}\eequiv{\tt [(fragment x), (fragment y)]} \footnote{This definition
wouldn't work if vectors entries could be pairs. At some point I may
add an operator that creates vectors of pairs, and then {\tt ::} will
be better justified}. For example {\tt [1, 2] :: [3, 4]}\eval{\tt [1,
2, 3, 4]}.  Since strings are really integer vectors, {\sf
concatenate} is also the string concatenation operator; {\tt "one" ::
"two"}\eequiv{\tt "onetwo"}.

There are actually two kinds of vectors: row vectors and column
vectors.  The two types are identical except in name, and how some
operators may behave.  Currently there is no way to create row
vectors.  {\sf Row-extract} ({\tt x\w y}) is therefore of no use.
This will change when {\sf transpose} is created.

\subsubsection{Complexes and Booleans}
\label{cxandb}

There is no literal form for complex numbers or booleans.  Therefore,
they must have their own constructors.  A complex number is created
with the built-in function {\sf complex}.  Its arguments are the real
and imaginary parts.  For example, the standard definitions include
{\tt i := complex(0, 1);}.  After this definition, complex numbers may
be entered in more familiar forms such as {\tt (2+3i)(4i)(1-i)}.

The destructor for complex numbers is the {\sf cxfrag} operator, which
takes a complex number and returns a pair of reals.  Thus {\tt
cxfrag(complex(1, 2)}\eval{\tt (1.0, 2.0)}.

Complex numbers are always made of two real numbers, there is no
special treatment of Gaussian integers of any sort.

Booleans also have no literal form.  They are defined in the standard
include file thus: {\tt True := 0 = 0; False := 1 = 0;}.  The closest
thing to a destructor for booleans is the {\sf if-else} operator.

\subsection{Logical}
\label{Logical}

The logical operators are {\sf and}, {\sf or}, and {\sf not}.  They
have syntaxes {\tt x and y}, {\tt x or y}, and {\tt not x},
respectively.  Their operands are expected to be booleans.  Each
performs the obvious operation.  They are strict.  That means that
when evaluating {\tt x and y}, if {\tt x} is false, then {\tt y} is
still evaluated.  Since fnord is purely functional, one usually cannot
tell the difference.  One exception to this is termination of
recursive functions, another is when one side contains an error.

\subsection{Relational}
\label{Relops}

The relational operators are {\sf equal}, {\sf exactly-equal}, {\sf
not-equal}, {\sf less-than}, {\sf greater-than}, {\sf less-or-equal},
and {\sf greater-or-equal}, with syntaxes {\tt = === != < > <= >=}.

As noted in Section~\ref{Expressions}, the relational
operators chain.  Operators chain in any combination, and
to any length.

All of the relationals are defined in the obvious way on the integers,
with {\sf equals} and {\sf exactly-equals} being identical.

On reals, {\sf equals} is up to $\epsilon$, {\sf less} (resp. {\sf
greater}) mean ``less than and not within $\epsilon$'', and {\sf
less-or-equal} means ``less than or exactly equal''.  $\epsilon$ is a
small real number, typically about $10^{-5}$.  Currently there is no
way for the user to control $\epsilon$.

On complexes, only {\sf equal}, {\sf not-equal}, and {\sf
exactly-equal} are defined; the first two are $\epsilon$ based.

{\sf Equals}, {\sf exactly-equals}, and {\sf not-equals} are also
defined on booleans and symbols.  They are {\em not} defined on
pairs, vectors, or functions of any sort.

\subsection{Conditional}
\label{Conditionals}

There are two conditional operators, {\sf if-else} and {\sf if}.  The
syntax for {\sf if-else} is {\tt x if y else z} and {\tt x if y} for
{\sf if}.

{\sf If-else} first evaluates the clause (the second argument) with an
expected type of {\tt B}.  If its value is true, then the first
argument is evaluated and returned, otherwise the third argument is
evaluated and returned.

\begin{bug}
When the {\sf if-else} is inside an apply that is mapping over a set,
then {\em all} arguments are fully evaluated, and the types of the
first and third arguments must be castible.  Eventually it will only
evaluate what's necessary, but the castible requirement will stay.
\end{bug}

The {\sf if} operator is similar to {\tt assert()} in C.  If the
clause is true, then the value of the {\sf if} is the value of the
first argument, otherwise it is an error.

The expected type of the first and third arguments is the expected
type received by the {\sf if-else} or {\sf if}.

\subsection{Arithmetic}
\label{Arithmetic}
\label{Dot Product}
\label{Vector Cross}
\label{MinMax}
\label{Power}

The arithmetic operations are {\sf plus}, {\sf minus}, {\sf opposite},
{\sf min}, {\sf max}, {\sf times}, {\sf divided-by}, {\sf modulo},
{\sf power}, {\sf dot}, and {\sf cross}.  They have syntaxes {\tt x +
y x - y -x x * y x / y x mod y x**y x . y x >< y}, except {\sf min}
and {\sf max}, which are built-in functions.

The arguments are evaluated as usual.  For {\sf plus}, {\sf minus},
{\sf min}, {\sf max}, {\sf opposite}, and {\sf cross} the expected
type of the argument(s) is the expected type received.  For {\sf
times} the expected type for both arguments is {\tt ?}.  For {\sf
divided-by} the expected type for the left argument is the expected
type received, and the expected type for the right argument is a
scalar.  [[Power]].  For {\sf dot} the expected type for both
arguments is {\tt A\h ?}, where {\sf dot} received type {\tt A}.  For
{\sf modulo}, the expected type for both arguments is {\tt Z}.

\begin{cav}
The expected type generated by {\sf times} is lame.
\end{cav}

{\sf Plus}, {\sf minus}, and {\sf opposite} work on vectors and
pair-trees of integers, reals, and complexes.  {\sf Min} and {\sf max}
are the same, except don't handle complexes.

{\sf Times} performs multiplication, either scalar-anything,
anything-scalar, matrix-matrix, or matrix-vector.  Integers, reals,
and complexes are supported.  Division may only be anything-scalar.

{\sf Power} works on scalars in any combination.  {\sf Modulo}
requires integers; its value with negative arguments is undefined.

{\sf Dot} takes two equal length vectors of scalars (integers, reals,
or complexes).  If the right vector is complex, it is conjugated.

{\sf Cross} works on length three vectors of reals or integers only.
If the arguments are sets, then a cartesian set product is performed,
see Section~\ref{Set Cross}.  {\sf Cross} is also a type operator, see
Section~\ref{TypeOperators}.

Examples of all the arithmetic operators can be found in
Table~\ref{arith}.

\begin{table*}
\begin{center}
{\tt
\begin{tabular}{|lll|}
\hline
{\rm Expression} & {\rm Result} & {\rm Type} \\
\hline
\hline
-2 & -2 & Z \\
-(1, 2) & (-1, -2) & (Z, Z) \\
\hline
1 + 2 & 3 & Z \\
{[1, 2, 3.1]} + [0, 1, 2] & [1, 3, 5.1] & R\h 3 \\
min((3, [2, 1]), (1.1, [2, 3])) & (1.1, [2, 1]) & (R, Z\h 2) \\
\hline
1.1 [2, 3] & [2.2, 3.3] & R\h 3 \\
(2, 3.1)/1 & (2, 3.1) & (R, R) \\
{[[1, 2], [3, 4]]} [5, 6] & [17, 39] & Z\h 2 \\
{[[1, 2], [3, 4]]} [[5, 6], [7, 8]] & [[19, 22], [43, 50]] & Z\h 2\h 2
\\ 
\hline
2**3 & 8 & R \\
-2**2 & -4 & R \\
(-2)**(1/2) & NaN & R \\
i**3 & 0 - 1i & C \\
i**i &  0.20788 + 0i & C \\
\hline
{[1, 2]} . [3, i] & 3 - 2i & C \\
"one" . "two" & 37177 & Z \\
\hline
{[1, 2, 3]} >< [4, 5, 6] & [-3, 6, -3] & Z\h 3 \\
\hline
10 mod 4 & 2 & Z \\
\hline
\end{tabular}
}
\end{center}
\caption{Examples of the Arithmetic Operators.}
\label{arith}
\end{table*}


\subsection{Scalar Math Functions}
\label{scalarOps}
An assortment of scalar math functions are provided.  They are all
built-in functions, so they don't have any syntax.  See Tables
\ref{table:ComplexFunctions} and \ref{table:RealFunctions} for
complete lists. They evaluate their argument with the same expected
type as they receive.  The type of the result is real, unless the
argument was complex, then it is complex.  This applies to square root
in particular: {\tt sqrt(-1)}\eval{\tt NaN}\footnote{{\tt NaN} is the
IEEE abbreviation for Not A Number.  Similarly {\tt 1/0}\eval{\tt R :
Infinity} rather than generating a fault or error.}, but {\tt sqrt(C :
-1)}\eval{\tt 0 + 1i}.

Give the branch cuts.

The scalar math functions map over sets.

\begin{table}
\begin{center}
{\sf
\begin{tabular}{|*{6}{l}|}
\hline
sin & cos & tan & ln & sqrt & exp \\
\hline
\end{tabular}
}
\end{center}
\caption{Functions for reals and complexes.  {\sf ln} and {\sf exp}
are base $e$}
\label{table:ComplexFunctions}

\begin{center}
\begin{tabular}{|llll|}
\hline
{\sf sinh} & {\sf cosh} & {\sf tanh} & hyperbolic \\
{\sf asin} & {\sf acos} & {\sf atan} & inverse \\
{\sf asinh} & {\sf acosh} & {\sf atanh} & inverse hyperbolic \\
\hline
\end{tabular}
\end{center}
\caption{Functions for reals only}
\label{table:RealFunctions}
\end{table}

\subsection{Differentiation}
\label{Prime}

{\sf Prime} takes functions are returns their derivative.  It can
handle a wide variety of domains and codomains.  It has syntax {\tt
x'}.  The type of resulting function has the same domain as the
argument and a codomain of {\tt ?}.  See Figure~\ref{derivex} for a
simple example.

\begin{figure}
\begin{verbatim}
F := R^2 -> R^2
  :  [x, y] -> [x y, x + y/2]
  ;
print F';
=> R^2 -> ? : fn
print F'[2, 3];
=> R^2^2 : [[3,   1],
            [2, 0.5]]
print F''[2,3];
=> R^2^2^2 : [[[0, 0], [1, 0]],
              [[1, 0], [0, 0]]]
\end{verbatim}
\caption{Evaluating the derivatives of a simple function.}
\label{derivex}
\end{figure}

Complicated vector (and worse) functions are handled
correctly\footnote{Almost; when converting the domain type into code,
row and column vector build operations should be exchanged.  Fnord
doesn't do this right now because the different vector types aren't
really distinguished.} because of the use of the domain type. See
Table~\ref{table:DifferentiationTypes} for examples.  It is easy to
predict what the type of the derivative is going to be: just
substitute the type of the codomain in for each base domain in the
domain.

\begin{bug}
Note that because of the way the vector build operator flattens
pair-trees, not all function types can be differentiated, and some may
be done incorrectly.  For example, a function of type {\tt (R\h 2, R)
-> (R\h 2, R)} requires {\tt [(R\h 2, R), (R\h 2, R)]}, which is
illegal, and {\tt (R\h 2, R) -> (R, R)} results in {\tt (R\h 4, (R,
R))} rather than {\tt ((R, R)\h 2, (R, R))}.
\end{bug}

\begin{table*}
\begin{center}
{\tt
\begin{tabular}{|l|l|}
\hline
{\rm function} & {\rm derivative} \\
\hline
R -> R  & R -> R  \\
R -> R\h n  & R -> R\h n  \\
R\h n -> R  & R\h n -> R\h n  \\
R\h n -> R\h m  & R\h n -> R\h m\h n  \\
(R\h 2\h 2, R\h 3) -> R\h 4 &(R\h 2\h 2, R\h 3) -> (R\h 4\h 2\h 2, R\h 4\h 3)  \\
(R, R) -> (R, R, R) &(R, R) -> ((R, R, R), (R, R, R))  \\
\hline
\end{tabular}
}
\end{center}
\caption{Types of Differentiated Functions}
\label{table:DifferentiationTypes}
\end{table*}

\begin{bug}
Not all the operators are handled.  For example, none of the
exclusively integer or set-oriented functions work.  The only ones
that {\em should} work and don't are {\sf polynomial}, {\sf min}, {\sf
max}, {\sf complex}, and {\sf cxfrag}.
\end{bug}

\subsection{Set Operations}
\label{Set Cross}
\label{Union}
\label{Interval}
\label{Triangle}
\label{Sample}
\label{Cardinality}

Besides the set constructor operator, there are several other ops that
create and manipulate sets.  {\sf Interval} and {\sf triangle} create
connected sets; they are built-in functions.  The {\sf union} and {\sf
cross} both take two sets and return another set; they have syntax
{\tt x union y} and {\tt x >< y}, respectively.  {\sf Sample} reduces
a set to its samples; it is a built-in function.  {\sf Cardinality}
returns the number of elements in a set, it has syntax {\tt \#x}.

{\sf Interval} creates a connected subset of the reals; {\tt
interval(0, 1)} creates the set of all reals between 0 and 1,
inclusive.  The first two arguments have expected type {\tt R}.  An
optional third argument has expected type {\tt Z}, it specifies the
number of samples taken on the interval.  It is an error if the first
argument is greater than the second, or if the third is less than one.
The samples are spaced evenly across the interval with one at the
lower bound and one at the upper bound.

{\sf Triangle} creates a connected subset of {\tt R\h n}.  If the
expected type received is {\tt \{R\h n\}} then the expected type used
to evaluate the first argument is {\tt R\h n\h 3}. The three columns
of the matrix are treated as the three vertices of the triangle.  The
expected type for the optional second argument is {\tt Z}.  It
specifies the number of samples along each edge of the triangle; the
total number of samples is $n(n+1)/2$.

The number of samples argument to both {\sf triangle} and {\sf
interval} is not used directly.  There is an interpreter global which
controls the sampling.  This parameter (a real number) is multiplied
by the passed value before use.  Currently there is no way to control
the global, it is always {\tt 1.0}. [[ the other globals should be
described in appropriate places, and there should be a section that
refers to them]].

{\sf Union} evaluates both its arguments with same expected type that
it receives.  They must both be sets.  It returns the mathematical set
union.  Duplicate elements are not removed; {\tt \{1, 2\} union \{2,
3\}}\eval{\tt \{1, 2, 2, 3\}}.

If the expected type received by {\sf cross} is {\tt (A, B)} then the
expected type of the first argument is {\tt A} and the expected type
of the second argument is {\tt B}.  Both arguments must be sets.  If
the first argument is $X$ and the second is $Y$, then the product is
$\{(x, y) | x \in X, y \in Y\}$.  It works correctly for connected
sets.  Note that to compute the connectivity of a product, one just
concatenates the connectivities of the two sets.

{\sf Sample} takes a set and returns a discrete set whose points are
the samples of its input.  Thus {\tt sample(interval(0, 1,
5))}\eval{\tt \{0.0, 0.25, 0.5, 0.75, 1.0\}}.

{\sf Cardinality} takes a set and returns the number of elements in
it.  If the set is infinite, then the cardinality is the opposite of
the dimension of the set, considered as a manifold.  If the set has
different parts with different dimensions, then the highest dimension
is used.  Thus if {\tt I := Interval(0, 1);} then {\tt \#I}\eval{\tt
-1} and {\tt \#(I >< I)}\eval{\tt -2} and {\tt \#(I >< I union
I)}\eval{\tt -2}.  See Section~\ref{Connectivity}.

\subsection{Associations}
\label{Associations}

Association lists in fnord (called a-lists) are similar to a-lists in
LISP.  In fnord, the cars of the cells must be symbols, and rather
than a list, you can have a tree.  You can create them by hand using
quote and pair like this: {\tt (`foo, 1), (`bar, True)}, or you can
use {\sf a-list-pair}: {\tt foo <- 1, bar <- True}.

The advantage of using trees rather than lists for a-lists is that two
can be combined with {\sf pair}, rather than something like append.
So if {\tt A} and {\tt B} are a-lists, then {\tt A, B} is also an
a-list.

Values can be extracted from a-lists using {\sf assoc}, a built-in
operator.  It takes a symbol to search for and an a-list, and returns
the value of that symbol.  It is an error if the symbol has no
association.  The a-list is searched left to right; the first
association found is returned.

\subsection{Reduce}
\label{Reduce}

{\sf Reduce} takes a discrete set, an associative function, and an
initial value.  The function is applied ``between'' the elements of
the set.  For example, if the function is {\tt (x, y) -> x + y} and
the initial value is {\tt 0}, then {\sf reduce} will sum the elements
of the set.  It is an error if the set is not discrete.  The function
should be associative because the order of its application is not
defined (this is to allow log-time implementation on a parallel
machine).  If it is not associative no error will be produced, but the
result is undefined.

\begin{bug}
Currently only the following functions are supported by reduce:
addition, min, and max of anything; multiplication of scalars; union
of sets; and logical or and and.
\end{bug}
\begin{bug}
\label{bug:reducecast}
The set cannot be a require casting to match the initial value.
\end{bug}

{\sf reduce} is a built-in function.  If the expected type received is
{\tt A}, then the expected type of the first argument is {\tt \{A\}},
the expected type for the second argument is {\tt (A, A) -> A}, and
the expected type for the third argument is {\tt A}.  The arguments
are all evaluated in standard fashion.

See Figure~\ref{factexample} for an example.

\begin{figure}
\begin{verbatim}
factorial
  := Z -> R
  :  n -> reduce(({R} : {3..n}), 
                 (a, b) -> a*b,
                 2)
  ;
print factorial(20);
=> R : 2.4329e+18

\end{verbatim}
\caption{Factorial using Reduce.}
\label{factexample}
\end{figure}

\subsection{Quote}
\label{Quote}

{\sf Quote} has syntax {\tt `x}.  Its argument must be a literal
symbol.  The result is a symbol value.  For example, the value of {\tt
`foo} is the symbol {\tt foo}.  This operator isn't used very often,
except when specifying the parent widget of a widget; see
Section~\ref{Window Widget}.

\subsection{Enumerate}
\label{Enumerate}

{\sf Enumerate} creates a flat pair-tree of consecutive integers.  It
has syntax {\tt x..y}.

Its arguments must be integers.  It creates a flat pair-tree whose
leavse are the integers starting with the left argument, and ending
with the right argument.  Thus {\tt (2..5)}\eval{\tt (2, 3, 4, 5)}.
{\sf Enumerate} is often combined with vector and set operations {\tt
\{1..3\}}\eval{\tt \{1, 2, 3\}} and {\tt [1..3]}\eval{\tt [1, 2, 3]}.

It is an error if the first argument is greater than the second.  They
may be the same: {\tt 1..1}\eval{\tt 1}.

\begin{bug}
{\sf Enumerate} does not work inside of an apply that is mapping over
a set.  This is because the type of its value is not entirely
determined by the type of its arguments.
\end{bug}

\subsection{Combinatorial}
\label{Factorial}
\label{Binomial}

{\sf Factorial} has syntax {\tt x!}.  The expected type is {\tt Z}.
Its value is the integer factorial of its argument.  Since integers
are usually limited to 32 bits, this function doesn't work for large
numbers.

{\sf Binomial} is a built-in function.  It takes two arguments; bother
are expected to be integers.  It returns a binomial coefficient, an
integer.  {\tt binomial(x, y)}\eequiv$\frac{x!}{y!(x-y)!}$.  This is
built-in rather than defined in terms of {\sf factorial} to avoid
overflow.

\subsection{Bitwise}
\label{bitops}

The bitwise operators are {\sf bitand}, {\sf bitxor}, {\sf bitor}, and
{\sf bitnot}.  They operate on integers.  They are built-in functions.
They evaluate their opperands with an expected type of {\tt Z}.  Each
performs the obvious operation.  Assume a 2's-complement
representation for negative integers.

\subsection{Polynomial}
\label{polynomial}

The {\sf polynomial} operator evaluates multi-variate polynomials
using Horner's rule.  It is a built-in function with two arguments.
The first argument is a scalar.  Its expected type is the same as the
expected type received by the polynomial operator.  The expected type
for the second argument is a vector of any length.  Integers, reals,
and complexes are all handled.

The vector contains the coefficients of the polynomial, and the scalar
is the value of the variable.  Thus {\tt polynomial(2, [1, 2,
3])}\eval{\tt 17}.

The vector can really be a tensor of any order.  The rank is reduced
by one by performing a polynomial calculation on each row of the (for
example) matrix.  The result is a vector; this can then be fed into
polynomial again to evaluate multi-variable polynomials.  For example
{\tt polynomial(x, polynomial(y, [[1, 0, 3], [4, 5, 0]]))}\eval$1 +
3y^2 + 4x + 5xy$.

\subsection{Implicit}
\label{Implicit}

{\sf Implicit} creates a set given a set and a predicate.  It is a
built-in function, the first argument is the set and the second is a
function mapping elements of the set to booleans.  There is also
special syntax for {\sf implicit}:  {\tt \{x in y | z\}}\eequiv{\tt
implicit(y, (type y) -> B : x -> z)}.

The resulting set consists of the elements from the input set that
pass the predicate, that is, for which the predicate function returns
true.  For example, 
\begin{verbatim}
A := {1..10};
print {x in A | x mod 2 = 0}}
=> {2, 4, 6, 8, 10}
\end{verbatim}
and 
\begin{verbatim}
D := sample(Patch((-2, 2, 50),
                  (-2, 2, 50)));
widget Show {[x, y] in D | x^2 - y^2 < 1};
\end{verbatim}
shows a mesh of points enclosed by a hyperbola.

\begin{bug}
{\sf Implicit} only works on discrete sets, eventually it will be able
to compute level surfaces.  But that is {\em much} harder, and {\em
much} more fun.
\end{bug}

\subsection{Type Operators}
\label{TypeOperators}
\label{Blank}

A number of operators work on type values as well as normal values.
These operators include: {\sf pair}, {\sf lambda}, {\sf cross}, {\sf
left}, {\sf right}, {\sf set}, and {\sf column-extract}.  There are
also a few operators that operate exclusively on types; they are
described in the following subsections.

Mostly, their operation as type operators is pretty simple:  if their
arguments are types, then they function as a type operator, otherwise
they behave normally.  There are a few complications, these are dealt
with later.

The actions of all the type operators is described in
Table~\ref{table:typeops}.

\begin{table*}
\begin{center}
\begin{tabular}{|lll|}
\hline
name & input & output \\
\hline
pair & {\tt (type X), (type Y)} & {\tt type (X, Y)} \\
{\sf lambda} & {\tt (type X) -> (type Y)} & {\tt type (X -> Y)} \\
{\sf cross} & {\tt (type X) >< (type Y)} & {\tt type (X, Y)} \\
{\sf left} & {\tt type (X, Y)} & {\tt type X} \\
{\sf left} & {\tt type (X -> Y)} & {\tt type X} \\
{\sf left} & {\tt type (X\h n)} & {\tt type X} \\
{\sf right} & {\tt type (X, Y)} & {\tt type Y} \\
{\sf right} & {\tt type (X -> Y)} & {\tt type Y} \\
{\sf right} & {\tt type (X\h n)} & {\tt n} \\
{\sf set} & {\tt \{type X\}} & {\tt type \{X\}} \\
{\sf column-extract} & {\tt (type X)\h n} & {\tt type (X\h n)} \\
{\sf row-extract} & {\tt (type X)\w n} & {\tt type (X\w n)} \\
{\sf blank} & {\tt ?} & {\tt ?} \\
\hline
\end{tabular}
\end{center}
\caption{Type Operators. {\tt X} and {\tt Y} are any types, {\tt n} is
an integer.}
\label{table:typeops}
\end{table*}

The type operators can also deal with arguments are that are not
types.  If an operand is a normal value with type {\tt \{X\}}, then
the type operator uses {\tt X}.  This is to facilitate ``types by
example''.  See Figure~\ref{typebyexample}.

\begin{figure}
\begin{verbatim}
U := Patch((0, 1, 10), (0, 1, 20));
X := U -> R^3 : u -> [u, v, sin(u v)];
\end{verbatim}
\caption{Type by Example. The type of {\tt X}
is {\tt R\h 2 -> R\h 3}; the type of {\tt U} is {\tt\{R\h 2\}}.}
\label{typebyexample}
\end{figure}

Note that ambiguity is introduced in two cases.  Both {\sf lambda} and
{\sf pair} can be interpreted either as type expressions or as regular
expressions.  For example, {\tt (R, R)} might mean {\tt (type R, type
R)} or {\tt type (R, R)}.  Also {\tt R -> R} might mean the identity
function, or {\tt type (R -> R)}.  These ambiguities are resolved
using the expected type received by the operator.

\subsubsection{The Type Operator}
\label{typeop}

{\sf Type} is used to extract the type of an object.  It evaluates its
argument, and returns the type of it.  Thus {\tt type 1}\eval{\tt type
Z} and {\tt type[\{1\}]}\eval{\tt type \{(Z\h 1)\}}.  If you pass it a
type, it just returns that type, thus {\tt type(type x)}\eequiv{\tt
type x}.

The symbols {\tt B}, {\tt Z}, {\tt R}, and {\tt C} are defined in the
standard library with the type operator:
\begin{verbatim}
B := type (0=0);
Z := type 0;
R := type 1.1;
C := type complex(0,0);
\end{verbatim}

\subsubsection{Type Matching}
\label{typematch}

There are two operators which can be used to determine if two types
are the same.  {\sf typematchx} makes sure they are exactly the same,
{\sf typematch} will allow casting.  Both return a boolean value; true
if they are the same.

\subsection{Casting}

All the operators cast their arguments up the base domain hierarchy
(from {\tt Z} to {\tt R} to {\tt C}) as needed.  Does anything more
than that need to be said?  Examples: compare {\tt [1, 1.1, 2]} with
{\tt (1, 1.1, 2)} and {\tt
\{1, 1.1, 2\}}.

\section{The Interpreter}
\label{Interpreter}

This section talks about the interpreter at a high level.  It also
touches on the implementation.

\subsection{Type Inference}
\label{expectedtype}

Fnord includes a very weak form of type inferencing.  The normal way
to evaluate an expression tree is as follows: recursively evaluate the
children, and then combine with the operator for this node.

In fnord, there is always a {\em expected} type.  Before evaluating
the children, an expcted type is calculated for each of them.  For
example, if we expect the result of an add operation to be an integer,
we can expect that both its operands are integers as well.

Not all cases are so easy; for example, if the expected type is {\tt
R\h 3\h 3} and the operation is multiplication, then you can't tell if
the right argument should be in {\tt R\h 3} or {\tt R\h 3\h 3} (it may
be a matrix-matrix or a matrix-vector multiplication).  In cases like
this, either a choice is made, or a expected type of {\tt ?} is used.

Computation and information flow down the tree as well as up the tree.

Say more; eg how this is used.  Mention index notation.

\subsection{Parallelism}

When a function is mapped over a set, it must be evaluated for each
point of the domain.  Each of these evaluations is independent; they
can be carried out in a SIMD (Single Instruction, Multple Data)
fashion.  Thus, fnord should be able to make good use of most sorts of
parallel hardware, including shared memory multiprocessors and vector
machines.

Even on a single processor machine, doing evaluation in SIMD fasion is
highly profitable.  The reason is that it reduces overhead.  The
function DAG is only traversed once rather than once for each domain
point.  The CPU spends its time in tight loops rather than chasing
pointers.

Because fnord is interpreted, however, maps and reduces consume far
more memory bandwidth than a compiled language could use.

\subsection{Performance}

Give numbers.  Integrate with previous section?  Comparison to other
packages?

Fnord performs very badly on flow of control.  Make more of this.


\subsection{Input}

The interpreter reads text from each of the file names specified on
its command line.  The file name ``stdin'' is treated specially.  If
no files are specified, then stdin is used.

There is also a gnu-emacs mode for editing and running fnord programs.
It is quite primitive, but functional.

\subsection{Commands}
\label{Commands}

Commands cause the interpreter to evaluate the expression,
and then do something with the result.  The commands are
\begin{description}
\item[print] writes the print-form of the value to standard out.
\item[debug] dumps internal data structures for the value
to standard out.
\item[eval] does nothing with the value.
\end{description}

The tokens are {\tt print}, {\tt debug}, and {\tt eval},
respectively.

\subsection{Directives}
\label{Directives}

The interpreter directives and their actions are
\begin{description}
\item[fix] serve as a marker for clear.  This may only
appear once.
\item[clear] remove all definitions since the interpreter
was fixed.
\item[quit] stop reading input and exit.
\end{description}

The tokens are {\tt FnordFix}, {\tt FnordClear}, and {\tt FnordQuit},
respectively.

Fix and clear are implemented using environments.  Definitions are
collected into a permanent environment until the fix.  Then a
temporary environment is created which points back to the permanent
environment, and definitions go into the temporary one.  The clear
clears the temporary environment, leaving the permanent environment
untouched.

The fix/clear functionality is used by the interactive text widget,
see Section~\ref{Text Widget}.

\section{Visualization System}
\label{Visualization}

The visualization system is based on {\em widgets}, so called because
they map one to one with X toolkit widgets (there are many exceptions,
but this is usually true).  Widgets provide input and output to fnorse
programs.  For example, the view widget displays a graphical
representation of the value of a fnord program.  That fnord program
may use the value of a slider widget in its computations.  In general,
widgets are used at the ends of the ``computational pipe,'' where the
purely functional model is less well suited.

A widget is created with a widget declaration.  See
Section~\ref{Syntax} for the syntax.  The expression should be an
a-list.  The associations of symbols in the a-list determine all
characteristics of the widget: type, appearance/geometry, possible
values, and behavior.

The association of the {\tt type} symbol should be a symbol that is
the name of a widget class.  See Table~\ref{table:widgetclasses} for
a complete list.  It determines the class of the widget.  [[probably
{\tt type} should be replaced with {\tt class}]].  This rarely
actually appears in user code.  Instead the widget functions from the
standard library are used, see Section~\ref{Standard Library}.

By default, widgets of each class are placed in the same window.  They
are stacked vertically.  View widgets are an exception; each is placed
in its own window.  It is possible to control exactly which widgets
appear in what windows, and how they are arranged, see
Section~\ref{Window Widget}.

The association of the {\tt name} symbol is used as the name for a
widget.  This name is usually displayed somewhere on the widget, or on
the title-bar of its window.  If the widget is bound to a symbol, then
the symbol is used as a default for the name.  If all else fails,
``default'' is used as the name.

\begin{table*}
\begin{center}
\begin{tabular}{|lllll|}
\hline
widget & usage & active & strobe & types \\
\hline
bitmap & input & no & no & {\tt Z\h ?\h ?} \\
button & input & no & yes & {\tt B} \\
checkbox & input & no & no & {\tt B} \\
editor & neither & & &  \\
evolve & input & yes & no & any \\
object & neither & & & \\
output & neither & & & \\
point & input & no & maybe & {\tt R\h n} or {\tt (B, R\h n)} \\
printer & output & & & any \\
slider & input & no & no & {\tt F} \\
tapedeck & input & yes & no & {\tt F} \\
typein & input & no & no & {\tt F} \\
view & output & yes & no & {\tt \{R\h n\}}, $2 \le n \le 4$ \\
window & neither & & & \\
\hline
\end{tabular}
\end{center}
\caption{Widget Classes and Types.}
\label{table:widgetclasses}
\end{table*}

\begin{table}
\begin{center}
\begin{tabular}{|l|}
\hline
append \\
bottom \\
color \\
dims \\
drag \\
field \\
height \\
init \\
left \\
max \\
min \\
modifiers \\
name \\
next \\
numUnits \\
parent \\
right \\
set \\
speed \\
strobe \\
top \\
type \\
width \\
zoom \\
\hline
\end{tabular}
\end{center}
\caption{Complete Attribute List.}
\label{table:AttributeList}
\end{table}

\subsection{Input Widgets}

There are a variety of input widgets, including buttons, checkboxes,
sliders, type-ins, and even a bitmap editor and tapedeck.

\subsubsection{Checkbox Widget}

The simplest widget is the checkbox widget.  Its value is either true
or false.  Each time you click on it, it toggles from true to false,
or vice versa.

\subsubsection{Button Widget}

The button widget is like the checkbox widget in that they are both
boolean valued.  It is different, however, because it is a {\em
strobe} widget.  Strobe widgets interact in special ways with
evolution widgets, see Section~\ref{Evolution Widget}.  The value of
the button is always false, except for after it is clicked it will be
true for exactly one iteration of any running evolution widgets.

\subsubsection{Slider Widget}

A slider widget appears as a scrollbar on the screen.  Its value is a
number between the values of the min and max attributes.  Min and max
default to 0 and 1.  If just min is set, then max defaults to min + 1.
When the widget is created, its value is taken from the {\tt init}
attribute.  The value of the widget can be either {\tt B}, {\tt Z},
{\tt R}, or {\tt C}, depending on the value of the {\tt field}
attribute (it is truncated for integers, and injected to the real line
for complexes).  The {\tt drag} attribute controls when the value of
the slider changes.  If it is false, then it will change only when the
mouse button is released.  If it is true, then it will change as the
mouse is moved.

\subsubsection{Type-in Widget}

Type-in widgets are similar to slider widgets, but the user specifies
an exact value by typing it in.  It doesn't need the {\tt min} and
{\tt max} attributes; it does recognize the {\tt field} attribute.
The value is updated when the Return key is pressed in the widget.

\subsubsection{Tapedeck Widget}

The tapedeck widget is also similar to the slider widget, but it can
change its value on its own at regular time intervals.  The widget
appears as three buttons below a label.  The buttons are are forward,
reverse, and stop.  The label displays the current value of the
tapedeck.  When the tapedeck is playing (either forward or reverse),
its value is repeatedly increased (decreased for reverse) by the value
of the {\tt speed} attribute.  The tapedeck widget recognizes the {\tt
init}, and {\tt field} attriutes; they have the same meaning as with
slider widgets.

\subsubsection{Bitmap Widget}

The bitmap widget is the most complex input widget.  Its value is an
array of integers, which are either zero or one (yes, they should be
booleans).  The size of the bitmap is determined by the {\tt width}
and {\tt height} attributes.  The size of one bit in the editor is
determined by the {\tt zoom} attribute; each bit is a square that many
pixels on a side.  Use the left mouse button to set bits, the right
button to clear bits, and the middle button either sets or clears,
whichever makes a difference (this is how a standard Macintosh
``pencil'' tool works).

\begin{cav}
Because the {\tt width} and {\tt height} are used for the size of the
bitmap, they cannot be used to place a bitmap widget inside a window
widget.  Use the {\tt bottom} and {\tt right} attributes instead.
\end{cav}

\subsubsection{Point Widget}

The point widget rivals the bitmap widget in complexity; it certainly
has more options.  The purpose of the point widget is to translate
clicks of the mouse (button two always) into 2d or 3d points.  The
type of the value of the strobe widget depends on the {\tt strobe} and
{\tt dims} attributes.  If strobe is on, then its value is {\tt (B,
R\h dims)}, otherwise just {\tt R\h dims}.  {\tt dims} must be either
2 or 3.  The boolean part of the value is true when the mouse is
clicked, or, additionally, when it is moved if {\tt drag} is true.

The point widget's {\tt parent} is usually set to a view widget.  In
this case, the click point is transformed to account for the view's
camera so that the widget's value corresponds to the location of the
mouse (See Figure~\ref{fig:paint}).  Otherwise the value is the
coordinates of the click in pixels.

Multiple point widgets may coexist in the same view widget.  The {\tt
modifiers} attribute is used to decide which view widget gets a
particular mouse click.  Its value is a standard Xt modifiers string,
for example {\tt None}, {\tt Shift}, {\tt Ctrl}, or {\tt cs} (which is
an abbreviation for control and shift).

\begin{bug}
There is a terrible memory leak when the point widget is strobed.
\end{bug}

\begin{figure}
\begin{verbatim}
N := D -> (D union {right pt})
          if (left pt) else D;

E := widget Evolve({}, N);

v := widget Show(E union
                 Axes union
                 Labels);

pt := widget Point,
             strobe <- True,
             parent <- `v,
             dims <- 3;
\end{verbatim}
\caption{Example Use of Point Widget.}
\label{fig:paint}
\end{figure}

\subsection{Output Widgets}

Output widgets provide one of two ways to get results out of the
interpreter (the other is the print command and its ilk).  They have
the advantage of being {\em dynamically updated}.  In general, an
output widget is given a fnord value to display.  The value is given
as the association of the {\tt set} attribute.

We say output widgets are dynamic because if the value of an input
widget is changed by the user (or even changes on its own accord), and
the value displayed by an output widget depends on (used in the course
of computation) the input widget, then the output value will be
recomputed and redisplayed in the output widget.  See
Figure~\ref{fig:depend} for an example

\begin{figure}
\begin{verbatim}
X := R^2 -> R^3
  :  [u, v] -> [u, v, (u v) ** n]
  ;
U := Patch((-1, 1, 30), (-1, 1, 30));
n := widget Slider(0, 10), field <- Z;
widget Print(n);
widget Show(X(U));
\end{verbatim}
\caption{Example of dynamic output widget.  When the slider for {\tt
n} is moved, the value in the print widget, and the surface in the
view widget both change to reflect the new value.}
\label{fig:depend}
\end{figure}

\subsubsection{Print Widget}

The print widget pretty-prints the value and displays the text in a
text editor widget.  If the {\tt append} attribute associates to
true, then when new values are displayed, they are appended to the
text (rather than replacing it).

\subsubsection{View Widget}

The view widget is by far the most used output widget.  It displays
three-dimensional geometry; that is, elements of {\tt \{R\h 3\}}.  It
will actually accept several sorts of sets, and convert them as
needed.  The conversions follow:
\begin{itemize}
\item Sets in {\tt \{R\h 2\}} are injected into the $XY$ plane.
\item Sets in {\tt \{R\h 3\}} are preserved.
\item Sets in {\tt \{R\h 4\}}, a coordinate is dropped and used as a
color index.
\item Sets in {\tt \{(R\h n, Z\h ?)\}} each point is a pair of a
geometric point (like one of the above), and a string.  The string is
printed as two-dimensional text starting at the point.  See
Figure~\ref{2dtext}.
\end{itemize}

\begin{figure}
\begin{verbatim}
U := Patch((-pi, pi, 20), (-pi, pi, 20));

F := R^2    -> R^4 
  :  [x, y] -> [sin x, cos x,
                sin y, cos y] / sqrt(2);

project
   := R^4        -> (R^3, Z^?)
   :  [xyz, w]   -> ([xyz] / (w - 1),
                     "-" if w < 0 else "+")
   ;

widget Show(project(F(U)));

\end{verbatim}
\caption{Two Dimensional Text.  Text is also useful for attaching
labels to various objects.  Note how {\tt xyz} is bound.}
\label{2dtext}
\end{figure}

\begin{figure}
\centerline{\psfig{figure=text-torus.ps,width=2in}}
\caption{The Text-Torus.}
\end{figure}

Objects in {\tt \{R\h 2\}} and {\tt \{R\h 3\}} may also be assigned a
color (here a single color is used for the entire set).  How to do
this, as well as how to select coordinates and color maps for the
other cases is explained in Section~\ref{Object Widget}.  In short,
the set attribute accepts object widgets which attach color
information to normal sets.

The operation of the view widget is relatively complicated.  The
object or objects are initially displayed in wire-frame.  They are
(collectively) scaled and translated to fill the window nicely.  The
camera projection is orthographic (parallel), and starts out looking
towards -Z, with +X pointing up.  Use the left mouse button to rotate
the objects.  The interaction technique is called ``virtual sphere''
rotation; one is supposed to imagine that the obects are imbedded in a
transparent, frictionless trackball; dragging the mouse rotates the
trackball.  The simulation is so accurate that if you release the
mouse button while moving the mouse, the sphere (and hence the
objects) will continue to spin indefinitely.  To stop the rotation,
click the left button (this is called {\em inertial} rotation).
Typing the 'r' key will reset camera to its initial state.

If the objects being viewed change due to user interaction with other
widgets, the scale and translate initially chosen by the view widget
may become obsolete.  To rescale and recenter the camera on the
object, type 's'.

The initial viewing mode is wire-frame mode.  In it, points appear as
points, lines appear as lines, and surfaces appear as rectangular
meshes edges only.  In hidden-surface mode, points appear as points,
lines appear as lines, and surfaces appear as opaque, edged triangles.
The space bar toggles between wire-frame and hidden-surface modes.

\subsection{Text Widget}
\label{Text Widget}

The text widget is entirely different from the other widgets; it is
neither input nor output.  It provides a mouse-based editor for
editing fnorse programs.  It can send its text directly to the
interpreter.  Before the text is sent to the interpeter, the
interpreter is cleared, as if by the clear directive (See
Section~\ref{Directives}).  Thus some large quantity of fnorse code
may be loaded into the interpeter and fixed.  Then each time the
contents of the text widget is executed the fixed environment is
unsullied by any previous runs.

The operation of the text widget is quite simple.  The actual text
editing commands are the standard Motif key bindings (?).  Buttons
exist to save and load files into the editor, run the current
contents, and quit (the program, not the widget).

Multiple text editors can coexist, but only one can be running at a
time.

\subsection{Evolution Widget}
\label{Evolution Widget}

The evolution widget is quite different from the other input widgets;
it maintains state.  You give it an initial state, and a next-state
function.  The function is iterated on the state to give the sequence
of values for the widget.

An evolution widget appears on the screen as a reset button and a
toggle switch.  When the toggle switch is on, the state of the widget
will be updated with its next function.  If the reset button is
pressed, the state reverts to its initial value, and evolution starts
over.

The value of the widget only changes when it is evolving (the toggle
switch is on), even if other widgets which contribute to its value
change.  For example, if the initial value of the evolution widget is
determined by a slider, then only when the evolution widget is reset
will the value of the slider be read.

Many evolution widgets can coexist; they run synchronously.  Thus if
multiple evolution widgets use the value of a strobe widget, then the
strobe widget will be true for all the evolution widgets for one
iteration.  In fact, all ``active'' widgets run synchronously, so, for
example, if the value of a tapedeck is used in a evolver, each value
from the tapedeck will be seen once by the evolver.  This also applies
to a view widget that is spinning intertially.  This applies to
inertially spinning view widgets as well.

See Figure~\ref{fig:evolve} for an example.

\begin{figure}
\begin{verbatim}
n := widget type <- `evolve, 
            init <- 0, 
            next <- (x -> x + 1);
widget Print(n);
\end{verbatim}
\caption{Example of Evolution Widget.  The value printed enumerates
the integers from 0.}
\label{fig:evolve}
\end{figure}

\subsection{Output Widget}
\label{Output Widget}

The output widget is a temporary hack.  Its functionality will
eventually be subsumed by the view widget.

The output widget generates a PostScript description of an image that
appears in a view widgets, and writes it to a file.  Type in the name
of the view widget (it must have a name to be printed!) and the file
to write to, and click on ``print'' button.  The view is printed
exactly as it appears, camera, hidden surface, and even size are all
maintained.

The generated code includes a bounding box, for easy inclusion into
\TeX\ documents with Psfig.

\subsection{Window Widget}
\label{Window Widget}

Window widgets exist solely as containers for other widgets.  With
them you can arrange your other widgets arbitrarily into windows, and
place them where you want within a window.

The size of the window widget is given in pixels by the width and
height associations.  Widgets are positioned inside of it with respect
to an imaginary grid placed over the widget.  The (integral) number of
divisions in the grid is given by the {\tt numUnits} association.
Its default is three.  The grid always has the same number of
divisions horizontally and vertically, regardless of the aspect ratio
of the window.

Another widget is placed inside of a window widget by setting its
{\tt parent} association to the {\em quoted} name of the window
widget.  The top, bottom, left, and right associations specify a
bounding box (using the parent's imaginary grid coordinate system,
numbering from zero) exactly containing the child widget.  You can
also use top, bottom, width, and height.  Again, if none (or an
incomplete set of) of these attributes are specified, the widgets are
stacked vertically.  The {\tt Location} function is usually used
instead of using these associations directly.

See Figure~\ref{fig:window} for an example.

\begin{figure*}
\begin{verbatim}
g := R -> R^2
  :  t -> [sin(a t), cos(b t)]
  ;
h := R -> R^2
  :  t -> [sin(a t), sin(b t)]
  ;
I := Interval(0, 6pi, 100);

myWin := widget Window(6), name<-"Lissajous Figures";
a := widget Slider(0, 1), parent <- `myWin, Location(3, 0, 4, 3);
b := widget Slider(0, 1), parent <- `myWin, Location(4, 0, 5, 3);
widget Show(g(I)),   parent <- `myWin, Location(0, 0, 3, 3);
widget Show(h(I)),   parent <- `myWin, Location(0, 3, 3, 6);
widget Print(a, b),  parent <- `myWin, Location(3, 3, 6, 6);

\end{verbatim}
\caption{Example of Window Widget.  Several objects are placed inside
a window.}
\label{fig:window}
\end{figure*}



\subsection{Object Widget}
\label{Object Widget}

The object widget is used to attach object-specific (as opposed to
view-specific) viewing information to a normal set.  Currently, the
only such information is color.  In the future other surface
properties and the lighting may be controlled from here.  Object
widgets are not associated with X toolkit widgets, they have no
manifestation on the screen of their own.

The object widget recognizes only two attributes, set and color.  The
value associated with set is the fnord value in {\tt \{R\h 2\}}, {\tt
\{R\h 3\}}, or {\tt \{R\h 4\}}.  The color attribute must be
associated with a string.  The string has several possible formats.
They are described in Table~\ref{table:color formats}.  An object with
solid color appears in that color (or the best approximation that the
window system can make).  If the color is indexed, then the specified
coordinate is used to interpolate between the two colors given.  Zero
results in the first color; one in the other color, and values in
between are linearly interpolated in RGB space.  Other values are
clamped.

\begin{table*}
\begin{center}
\begin{tabular}{|lll|}
\hline
format & meaning & example \\
\hline
{\tt "}{\em color}{\tt "} & solid & {\tt "green"} \\
{\tt "}{\em coord}{\tt :}{\em color}{\tt ->}{\em
color}{\tt "} & indexed & {\tt"4:green->\#2ff"} \\ 
\hline
\end{tabular}
\end{center}
\caption{Object Widget Color String Formats.}
\label{table:color formats}
\end{table*}

\section{The Standard Library}
\label{Standard Library}

explain contents std.fnorse, and any other such files I write.

\section{Conclusion}
[[ the usual ]]

\section{Acknowledgments}

I spent many months talking to and designing with Nick Thompson
(nix@sgi.com).  His influence is strong, and indeed, many of these
ideas are his.  Nick Thompson also designed and implemented the
parser.

Matthew Stone (mas@cs.brown.edu) implemented the Motif interface,
hidden surface removal, and PostScript output.

This work would not be possible without the support and funding of
Thomas Banchoff, Andy Witkin, and Dana Scott, or the hospitality and
equipment of the Computer Graphics Group at Brown.

The Xt part of the bitmap widget was written by Brian Totty
(totty@cs.uiuc.edu).  His code's copyright requires that the following
notice be included in this manual:
\begin{quote}
Copyright 1990 Brian Totty

Permission to use, copy, modify, distribute, and sell this software
and its documentation for any purpose is hereby granted without fee,
provided that the above copyright notice appears in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Brian Totty or
University of Illinois not be used in advertising or publicity
pertaining to distribution of the software without specific, written
prior permission.  Brian Totty and University of Illinois make no
representations about the suitability of this software for any
purpose.  It is provided ``as is'' without express or implied warranty.

Brian Totty and University of Illinois disclaim all warranties with
regard to this software, including all implied warranties of
merchantability and fitness, in no event shall Brian Totty or
University of Illinois be liable for any special, indirect or
consequential damages or any damages whatsoever resulting from loss of
use, data or profits, whether in an action of contract, negligence or
other tortious action, arising out of or in connection with the use or
performance of this software.

\end{quote}

\tableofcontents

\end{document}
