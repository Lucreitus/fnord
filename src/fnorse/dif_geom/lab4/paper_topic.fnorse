/****************************************************************
 *
 * Copyright 1990, Brown University, Providence, RI
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 ****************************************************************/

/**********************************************************************
 * RCH 10/1/90
 *
 * Unfortunately I've forgotten what the name of this type of 
 * curve is. We discussed it in class on Mon 10/1/90 and it was
 * someone's paper topic. 
 *
 * This uses a formula that I don't have time to comment well 
 * right now. It draws the original curve in black. It draws the 
 * curve generated by the point on each tangent that is closest to
 * A in red. It marks A with the green Axes.
 *
 * everything is done in 2D.
 * 
 **********************************************************************/

/* 
 * so can adjust point
 */

a := widget Slider(-3, 3), init<-0, name<-"x of A";
b := widget Slider(-3, 3), init<-0, name<-"y of A";
c := widget Slider( 1, 4), init<-1, name<-"ratio of ellipse axes";

/*
 * point of lines is A 
 */
A := [ a, b ];

/*
 * start w/ circle 
 * instead of doing equations to A, just offset circle
 */
curveDom := Interval( 0, 2pi, 80 );
theCurve
   := R->R^2
   : t -> [  cos(t), (1/c)*sin(t) ]  - A
   ;

/*
 * rotate 90 ccw - 2D
 */
Rot   
   := R^2 -> R^2
   : [x, y] -> [ -y, x ]
   ;

/*
 * now make curve of 
 * lines perp to tang
 *
 * OK - explanation:
 * 
 * the tangent line for a givne t is 
 *   L(t) = X(t) + u * X'(t) 
 * Thus a vector with perpendicular slope will be a 
 * 90 degree ccw rotation of X'(t). So, if we normalize that
 * and take the dot product with the vector representing any 
 * point on L(t), it will give us the shortest distance to 
 * the line from the origin. We can use X(t) for our point 
 * on the line. 
 * The direction to go in this distances is going to be 
 * Rot( X'(t) ). So if we normalize X'(t) again and multiply it
 * by the scalar result from above, we will have the point on the 
 * tangent line we seek. Thus we have a neat formular in terms
 * of t for the set of points on the tangent lines. 
 *
 * perp = Normalize( X'(t) );
 * myCurve = ( X(t).perp ) * perp
 * 
 */
f := theCurve; /* short-hand */
/*
 * define unit vec perp to line. 
 */
myPerp 
   := R -> R^2
   : t -> Normalize( Rot( theCurve'(t)) );	

myCurve
   := R  -> R^2
   : t -> ( f(t) . myPerp(t) ) * myPerp(t)
   ;

myView := widget type<-`view;

/* original curve */
widget type<-`vobject, set<-( theCurve curveDom ),
   color<-"black", parent<-`myView;

/* derivative curve */
widget type<-`vobject, set<-( myCurve curveDom ),
   color<-"red", parent<-`myView;

widget type<-`vobject, set<-( Axes ),
   color<-"green", parent<-`myView;




